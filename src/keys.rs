use std::ops::Add;

use amcl_wrapper::field_elem::FieldElement;
use amcl_wrapper::group_elem::GroupElement;
use amcl_wrapper::group_elem_g2::G2;
use amcl_wrapper::group_elem_g1::G1;

use crate::errors::PSError;
use crate::{VerkeyGroup, SignatureGroup};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Sigkey {
    pub x: FieldElement,
    pub y: Vec<FieldElement>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Verkey {
    pub X_tilde: VerkeyGroup,
    pub Y_tilde: Vec<VerkeyGroup>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SKrss {
    pub x: FieldElement,
    pub y: FieldElement,
}  // Secret key consists of two random scalars x and y

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PKrss {
    pub g: SignatureGroup,
    pub g_tilde: VerkeyGroup,
    pub Y_i: Vec<Option<SignatureGroup>>,
    pub X_tilde: VerkeyGroup,
    pub Y_tilde_i: Vec<VerkeyGroup>,
} // Public key is a a group element X~, a vector Y~ of group elements
// a vector Y (split to two seperate vectors here), and two group elements
// why is n+1 not used
// Parameters generated by random oracle.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Params {
    pub g: SignatureGroup,
    pub g_tilde: VerkeyGroup,
}

impl Params {
    /// Generate g1, g2. These are shared by signer and all users. Picks a point from G1 and G2
    pub fn new(label: &[u8]) -> Self {
        let g = SignatureGroup::from_msg_hash(&[label, " : g".as_bytes()].concat()); // generate g from G1 -> correct
        let g_tilde = VerkeyGroup::from_msg_hash(&[label, " : g_tilde".as_bytes()].concat()); // generate g~ from G2 -> correct
        Self { g, g_tilde }
    }
}  // This seems correct, it generates two elements from G1 and G2.

/// Generate signing and verification keys for scheme from 2016 paper
pub fn keygen(count_messages: usize, params: &Params) -> (Sigkey, Verkey) {
    // TODO: Take PRNG as argument
    let x = FieldElement::random();
    let X_tilde = &params.g_tilde * &x;
    let mut y = vec![];
    let mut Y_tilde = vec![];
    for _ in 0..count_messages {
        let y_i = FieldElement::random();
        Y_tilde.push(&params.g_tilde * &y_i);
        y.push(y_i);
    }
    (Sigkey { x, y }, Verkey { X_tilde, Y_tilde })
}

// RSS
// Takes the parameters and returns the secret key and public key
// Secret key correctly prints - two random field elements.
// Public key seems to be correct. The vector lengths add up, and all the maths needed is what generates X~ (multiplication)
pub fn rsskeygen(count_messages: usize, params: &Params) -> (SKrss, PKrss) {
    // get owned copies of g, g~
    let g = params.g.clone();
    let g_tilde= params.g_tilde.clone();

    let x = FieldElement::random(); // Randomly generate x, ok
    let y = FieldElement::random(); // Randomly generate y, ok
    let X_tilde = &g_tilde * &x; // Calculate X~, ok

    let mut Y_tilde_i = Vec::new(); // Create a vector to store Y~i
    for i in 1..=count_messages{
        // Calculate y^i (mod arithmetic because y in Z2p)
        let y_i = FieldElement::pow(&y, &FieldElement::from(i as u64));

        // add g~ mul y^i to Y~i
        Y_tilde_i.push((&g_tilde).scalar_mul_variable_time(&y_i));
    }
    // Y_tilde_i seems correct in terms of length and input

    // Given that the index of redacted and unredacted messages do not intersect, 
    // the pairing can be computed without knowledge of a specific element g^y^(n+1).
    // So instead of considering 2n elements, we consider 2n-1. Hence, for the public
    // key we compute only [1,n] and [n+2,2n], leaving the n+1 value.
    let mut Y_i = Vec::new();
    for i in 1..=(2*count_messages) {
        if i == count_messages+1 {
            Y_i.push(None);
        } else {
            let y_i = FieldElement::pow(&y, &FieldElement::from(i as u64));
            Y_i.push(Some((&g).scalar_mul_const_time(&y_i)))
        }
    }

   (
    SKrss {x , y},
    PKrss {g , g_tilde , Y_i, X_tilde , Y_tilde_i}
    )
}
// RSS

/// Generate signing and verification keys for scheme from 2018 paper. The signing and verification
/// keys will have 1 extra element for m'
pub fn keygen_2018(count_messages: usize, params: &Params) -> (Sigkey, Verkey) {
    keygen(count_messages + 1, params)
}

#[cfg(test)]
mod tests {
    use crate::rsssig::MathIndex;

    use super::*;
    // For benchmarking
    use std::time::{Duration, Instant};
    #[test]
    fn test_keygen() {
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk, vk) = keygen(count_msgs, &params);
        assert_eq!(sk.y.len(), count_msgs);
        assert_eq!(vk.Y_tilde.len(), count_msgs);
    }

    #[test]
    fn test_keygen_2018() {
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk, vk) = keygen_2018(count_msgs, &params);
        assert_eq!(sk.y.len(), count_msgs+1);
        assert_eq!(vk.Y_tilde.len(), count_msgs+1);
    }
    #[test]
    fn test_rsskeygen() {
        let count_msgs = 3;
        let params = Params::new("test".as_bytes());
        let (sk, pk) = rsskeygen(count_msgs, &params);

        // test Y_i
        assert_eq!(pk.Y_i.len(), 2*count_msgs);
        assert_eq!(pk.Y_i.at_math_idx(count_msgs+1), &None);
        let Y_i_calc = vec![
            Some(params.g.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(1)))),
            Some(params.g.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(2)))),
            Some(params.g.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(3)))),
            None,
            Some(params.g.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(5)))),
            Some(params.g.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(6))))
            ];
        assert_eq!(pk.Y_i, Y_i_calc);


        // test Y_tilde_i
        let Y_tilde_i_calc = vec![
            params.g_tilde.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(1))),
            params.g_tilde.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(2))),
            params.g_tilde.scalar_mul_const_time(&sk.y.pow(&FieldElement::from(3)))
        ];
        assert_eq!(pk.Y_tilde_i,Y_tilde_i_calc);
    }

}
