use std::ops::Add;

use amcl_wrapper::field_elem::FieldElement;
use amcl_wrapper::group_elem::GroupElement;
use amcl_wrapper::group_elem_g2::G2;
use amcl_wrapper::group_elem_g1::G1;

use crate::errors::PSError;
use crate::{VerkeyGroup, SignatureGroup};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Sigkey {
    pub x: FieldElement,
    pub y: Vec<FieldElement>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Verkey {
    pub X_tilde: VerkeyGroup,
    pub Y_tilde: Vec<VerkeyGroup>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SKrss {
    pub x: FieldElement,
    pub y: FieldElement,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PKrss {
    pub g: SignatureGroup,
    pub g_tilde: VerkeyGroup,
    pub Y_j_1_to_n: Vec<SignatureGroup>,
    pub Y_k_nplus2_to_2n: Vec<SignatureGroup>,
    pub X_tilde: VerkeyGroup,
    pub Y_tilde_i: Vec<VerkeyGroup>,
}

// Parameters generated by random oracle.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Params {
    pub g: SignatureGroup,
    pub g_tilde: VerkeyGroup,
}

impl Params {
    /// Generate g1, g2. These are shared by signer and all users.
    pub fn new(label: &[u8]) -> Self {
        let g = SignatureGroup::from_msg_hash(&[label, " : g".as_bytes()].concat()); // generate g from G1
        let g_tilde = VerkeyGroup::from_msg_hash(&[label, " : g_tilde".as_bytes()].concat()); // generate g~ from G2
        Self { g, g_tilde }
    }
}

/// Generate signing and verification keys for scheme from 2016 paper
pub fn keygen(count_messages: usize, params: &Params) -> (Sigkey, Verkey) {
    // TODO: Take PRNG as argument
    let x = FieldElement::random();
    let X_tilde = &params.g_tilde * &x;
    let mut y = vec![];
    let mut Y_tilde = vec![];
    for _ in 0..count_messages {
        let y_i = FieldElement::random();
        Y_tilde.push(&params.g_tilde * &y_i);
        y.push(y_i);
    }
    (Sigkey { x, y }, Verkey { X_tilde, Y_tilde })
}

// RSS
// Takes the parameters and returns the secret key and public key
pub fn rsskeygen(count_messages: usize, params: &Params) -> (SKrss, PKrss) {
    let x = FieldElement::random(); // randomly sample x
    let y = FieldElement::random(); // randomly sample y
    let X_tilde = params.g_tilde.scalar_mul_const_time(&x); // X~ = g~ mul x
    
    let g = params.g.clone(); // cannot move out of `params.g` which is behind a shared reference
    let g_tilde= params.g_tilde.clone(); // cannot move out of `params.g_tilde` which is behind a shared reference

    let mut Y_tilde_i:Vec<VerkeyGroup> = vec![]; // Create a vector to store Y~i
    let mut i_exponent = FieldElement::one(); // create an index for Y~i and for calculating y^i (mod arithmetic)
    
    for _ in 0..count_messages{
        let y_i=
        FieldElement::pow(&y,&i_exponent); // Calculate y^i (mod arithmetic because y in Z2p)
        
        let g_tilde_y_i = 
        params.g_tilde.scalar_mul_variable_time(&y_i); // Calculate g~ mul y^i
        
        Y_tilde_i.push(g_tilde_y_i); // add g~ mul y^i to Y~i
        
        let i_exponent = 
        FieldElement::add_assign_(&mut i_exponent, &FieldElement::one()); //increment i by 1
    }
    
    let mut  Y_j_1_to_n:Vec<G2> = vec![]; // Create a vector to store Yi for i = 1...n
    i_exponent = FieldElement::one(); // Reset i back to 1

    for _ in 0..count_messages{
        let y_i=
        FieldElement::pow(&y,&i_exponent); // Calculate y^i 
        
        let g_y_i = 
        params.g.scalar_mul_variable_time(&y_i); // Calculate g mul y^i
        
        Y_j_1_to_n.push(g_y_i); // Add g mul y^i to Y_tilde_i
        
        let i_exponent = 
        FieldElement::add_assign_(&mut i_exponent, &FieldElement::one()); //increment i by 1
    }
   
    let mut  Y_k_nplus2_to_2n:Vec<G2> = vec![]; // Create a vector to store Yi for i=n+2...2n
    i_exponent = FieldElement::one(); // Reset i back to 1

    for _ in (count_messages+2)..(2*count_messages) { 
        let y_i=FieldElement::pow(&y,&i_exponent); // Calculate y^i
        let g_y_i = params.g.scalar_mul_variable_time(&y_i); // Calculate g mul y^i       
        Y_k_nplus2_to_2n.push(g_y_i); // push g mul y^i to Y~i
        let i_exponent = 
        FieldElement::add_assign_(&mut i_exponent, &FieldElement::one()); // increment i by 1
    }
    // secret key: {x,y} public key: {g, g~, Yi (i=1...n), Yi (i=n+2...2n), X~, Y~}
   (SKrss {x , y}, PKrss {g , g_tilde , Y_j_1_to_n , Y_k_nplus2_to_2n , X_tilde , Y_tilde_i})
}
// RSS

/// Generate signing and verification keys for scheme from 2018 paper. The signing and verification
/// keys will have 1 extra element for m'
pub fn keygen_2018(count_messages: usize, params: &Params) -> (Sigkey, Verkey) {
    keygen(count_messages + 1, params)
}

#[cfg(test)]
mod tests {
    use super::*;
    // For benchmarking
    use std::time::{Duration, Instant};
    #[test]
    fn test_keygen() {
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk, vk) = keygen(count_msgs, &params);
        assert_eq!(sk.y.len(), count_msgs);
        assert_eq!(vk.Y_tilde.len(), count_msgs);
    }

    #[test]
    fn test_keygen_2018() {
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk, vk) = keygen_2018(count_msgs, &params);
        assert_eq!(sk.y.len(), count_msgs+1);
        assert_eq!(vk.Y_tilde.len(), count_msgs+1);
    }
    #[test]
    fn test_rsskeygen() {
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk, pk) = rsskeygen(count_msgs, &params);
        println!("{:?}",sk);
        println!("{:?}",pk);
    } // KeyGen seems to be okay - it runs but cannot tell if it is correct structurally

}
