use amcl_wrapper::field_elem::FieldElement;
use amcl_wrapper::group_elem::GroupElement;
use std::convert::From;
use crate::errors::PSError;
use crate::{VerkeyGroup, SignatureGroup};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Sigkey {
    pub x: FieldElement,
    pub y: Vec<FieldElement>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Verkey {
    pub X_tilde: VerkeyGroup,
    pub Y_tilde: Vec<VerkeyGroup>,
}

// Parameters generated by random oracle.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Params {
    pub g: SignatureGroup,
    pub g_tilde: VerkeyGroup,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Skrss {
    pub x: FieldElement,
    pub y: FieldElement,
}

pub struct Pkrss {
    pub X: VerkeyGroup,
    pub Y_tilde_i: Vec<FieldElement>,
    pub Y_i: Vec<FieldElement>
}

impl Params {
    /// Generate g1, g2. These are shared by signer and all users.
    pub fn new(label: &[u8]) -> Self {
        let g = SignatureGroup::from_msg_hash(&[label, " : g".as_bytes()].concat());
        let g_tilde = VerkeyGroup::from_msg_hash(&[label, " : g_tilde".as_bytes()].concat());
        Self { g, g_tilde }
    }
}

/// Generate signing and verification keys for scheme from 2016 paper
pub fn keygen(count_messages: usize, params: &Params) -> (Sigkey, Verkey) {
    // TODO: Take PRNG as argument
    let x = FieldElement::random();
    let X_tilde = &params.g_tilde * &x;
    let mut y = vec![];
    let mut Y_tilde = vec![];
    for _ in 0..count_messages {
        let y_i = FieldElement::random();
        Y_tilde.push(&params.g_tilde * &y_i);
        y.push(y_i);
    }
    (Sigkey { x, y }, Verkey { X_tilde, Y_tilde })
}

pub fn rsskeygen(count_messages: usize, params: &Params) -> (Skrss , Pkrss) {
    let x = FieldElement::random(); // Generate x
    let y = FieldElement::random(); // Generate y
    let X_tilde = &params.g_tilde * &x; // Calculate X
    let mut i_exponent = FieldElement::one(); // start of exponent
    let Y_tilde_i: Vec<FieldElement> = vec![]; // Generate Y_tilde_i
    let Y_i: Vec<FieldElement> = vec![]; // Generate Y_i
    for i in 0..count_messages{
        let y_i = FieldElement::pow(&y,&i_exponent); // Calculate y^i
        Y_tilde_i.push(FieldElement::pow(&params.g_tilde, &y_i); // Need to convert g_tilde to Field Element
        i_exponent = FieldElement::plus(&i_exponent,&FieldElement::one()); // increment i exponent
    }
    for i in 0..(2*count_messages){
        if i == (count_messages+1){
            i += 1;
        } else{
            let y_i = FieldElement::pow(&y,&i_exponent); // Calculate y^i
            Y_i.push(FieldElement::pow(&params.g, &y_i)); // Need to convert g to Field Element
        }
    }
    (Skrss {x,y} , Pkrss{X_tilde, Y_tilde_i, Y_i})
}


/// Generate signing and verification keys for scheme from 2018 paper. The signing and verification
/// keys will have 1 extra element for m'
pub fn keygen_2018(count_messages: usize, params: &Params) -> (Sigkey, Verkey) {
    keygen(count_messages + 1, params)
}

#[cfg(test)]
mod tests {
    use super::*;
    // For benchmarking
    use std::time::{Duration, Instant};

    #[test]
    fn test_keygen() {
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk, vk) = keygen(count_msgs, &params);
        println!("{:?}", sk);
    }

    #[test]
    fn test_rsskeygen(){
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk) = rsskeygen(count_msgs, &params);
        println!("{:?}", sk);
    }

    #[test]
    fn test_keygen_2018() {
        let count_msgs = 5;
        let params = Params::new("test".as_bytes());
        let (sk, vk) = keygen_2018(count_msgs, &params);
        assert_eq!(sk.y.len(), count_msgs+1);
        assert_eq!(vk.Y_tilde.len(), count_msgs+1);
    }
}
